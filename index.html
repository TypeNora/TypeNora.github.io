<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>バーチャロンキャラ選択ルーレット（PWA・モバイル対応・パステル色相環）</title>
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#ffffff">
<link rel="apple-touch-icon" href="icon-192.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<style>
  :root { --gap:12px; --radius:12px; --ink:#111; --bg:#f7f7f7; --border:#ddd; }
  *{ box-sizing:border-box; }
  body{
    margin:0; padding:16px;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Noto Sans JP,Meiryo,sans-serif;
    color:var(--ink); background:var(--bg);
    touch-action:manipulation;
  }
  h1{ margin:0 0 12px; font-size:20px; }
  .wrap{ max-width:1200px; margin:0 auto; }
  .grid{ display:grid; gap:var(--gap); grid-template-columns:1fr; }
  @media (min-width:1100px){ .grid{ grid-template-columns:460px 1fr; } }
  .panel{ background:#fff; border:1px solid var(--border); border-radius:var(--radius); padding:16px; }

  .btns{ display:flex; flex-wrap:wrap; gap:8px; margin-top:8px; }
  button{
    cursor:pointer; padding:10px 14px; border-radius:10px;
    border:1px solid #bbb; background:#fff; min-height:44px; font-size:16px;
  }
  button[disabled]{ opacity:.5; cursor:not-allowed; }

  .checkwrap{ display:grid; grid-template-columns:1fr; gap:8px; border:1px solid #ccc; border-radius:10px; padding:10px; max-height:480px; overflow:auto; }
  .row{ display:grid; grid-template-columns: auto minmax(0,8fr) minmax(60px,1fr) minmax(60px,1fr); align-items:center; gap:8px; }
  .name{ width:100%; min-width:0; padding:8px 10px; border:1px solid #bbb; border-radius:8px; }
  .weight{ width:100%; min-width:0; padding:8px 10px; border:1px solid #bbb; border-radius:8px; text-align:right; }
  .remove{ width:100%; padding:8px 10px; }

  @media (max-width:480px){
    .row{ display:flex; }
    .row > .name{ flex:1 1 auto; width:auto; }
    .row > .weight{ flex:0 0 60px; width:60px; }
    .row > .remove{ flex:0 0 auto; width:auto; }
  }
  .small{ font-size:12px; color:#555 }

  .wheel-wrap{ display:flex; flex-direction:column; align-items:center; gap:10px; }
  .spacer{ height:8px; }
  .announce{
    min-height:56px; padding:8px 14px; border:2px solid #222; border-radius:10px;
    background:#fff; font-weight:800; font-size:clamp(22px, 6vw, 36px); line-height:1.2; text-align:center;
  }
  .announce.pop{ animation: pop 260ms ease-out; transform-origin:center; }
  @keyframes pop{ from{ transform:scale(0.85) } to{ transform:scale(1) } }

  .pointer{ width:0; height:0; border-left:12px solid transparent; border-right:12px solid transparent; border-top:20px solid #d22; position:relative; top:2px; }

  canvas#wheel{
    display:block; width:100%; height:auto; max-width:520px;
    border:2px solid #222; border-radius:50%; background:#fff;
  }

  .ctrls{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-top:10px; }
  .ctrl{ display:flex; flex-direction:column; gap:4px; }
  .ctrl input{ padding:8px 10px; border:1px solid #bbb; border-radius:8px; }
  .note{ font-size:12px; color:#555 }
</style>
</head>
<body>
  <div class="wrap">
    <h1>バーチャロンキャラ選択ルーレット</h1>

    <div class="grid">
      <div class="panel">
        <strong>キャラクター編集</strong>
        <div id="presets" class="small" style="display:grid; gap:6px; margin:8px 0 10px 0;">
          <div><strong>プリセット：</strong></div>
          <label><input type="radio" name="preset" value="OMG"> OMG</label>
          <label><input type="radio" name="preset" value="オラタン" checked> オラタン</label>
          <label><input type="radio" name="preset" value="フォース"> フォース</label>
          <label><input type="radio" name="preset" value="禁書VO"> 禁書VO</label>
        </div>
        <div id="checks" class="checkwrap" aria-label="キャラクター編集リスト"></div>
        <div class="btns">
          <button id="allOn">全選択</button>
          <button id="allOff">全解除</button>
          <button id="invert">反転</button>
        </div>
        <div class="btns">
          <input id="newName" class="name" placeholder="新しいキャラ名" />
          <input id="newWeight" class="weight" type="number" min="0.1" max="10" step="any" value="1" inputmode="decimal" />
          <button id="add">追加</button>
        </div>
        <div class="small">※重みは 0.1〜10。未入力の場合は1になります。名称は重複可ですが、同名の別キャラを分けたい場合は表記を変えてください。</div>
      </div>

      <div class="panel">
        <strong>ルーレット（円盤回転）</strong>
        <div class="btns" style="margin-top:10px;">
          <button id="start">スタート</button>
          <button id="stop"  disabled>ストップ</button>
        </div>
        <div class="spacer"></div>
        <div class="wheel-wrap">
          <div id="current" class="announce">（未開始）</div>
          <div class="pointer" title="12時の固定ポインタ（▼）"></div>
          <canvas id="wheel"></canvas>
        </div>

        <div class="ctrls">
          <div class="ctrl">
            <label for="maxTime">最大ルーレット時間（秒）</label>
            <input id="maxTime" type="number" min="1" max="20" step="0.1" value="3.0" inputmode="decimal" />
          </div>
          <div class="ctrl">
            <label for="decelTime">ストップから止まるまで（秒）</label>
            <input id="decelTime" type="number" min="0.2" max="3" step="0.1" value="1.0" inputmode="decimal" />
          </div>
        </div>
        <div class="note">※「最大ルーレット時間」＝スタートから自動停止まで。「ストップから止まるまで」＝減速開始から完全停止まで。</div>
      </div>
    </div>

    <div class="note" style="margin-top:10px;">ローカル完結（オフライン可／外部通信なし）。このままPWAとしてホーム画面追加できます。</div>
  </div>

<script>
(() => {
  "use strict";
  const $ = (s, p=document) => p.querySelector(s);
  const refs = {
    checks: $('#checks'),
    allOn:  $('#allOn'), allOff: $('#allOff'), invert: $('#invert'),
    add: $('#add'), newName: $('#newName'), newWeight: $('#newWeight'),
    start:  $('#start'), stop: $('#stop'),
    wheel:  $('#wheel'), current: $('#current'),
    maxTime: $('#maxTime'), decelTime: $('#decelTime')
  };

  const PRESETS = {
    'OMG': ['テムジン','バイパ－Ⅱ','ドルカス','ベルグドル','バルバスバウ','アファームド','フェイ','ライデン'],
    'オラタン': ['ライデン','シュタイン','グリス','テムジン','テンパチ','バル','エンジェ','アジム','スぺ','コマンダー','バトラー','ストライカー','サイファー','フェイ','ドル'],
    'フォース': ['TEMJIN系列','RAIDEN系列','VOX系列','BAL系列','APHARMD J系列','APHARMD T系列','MYZR系列','SPECINEFF系列','景清系列','FEI-YEN系列','ANGELAN系列','GUARAYAKHA'],
    '禁書VO': ['テムジン','バルルルーン','ライデン','スペシネフ','フェイ・イェン','エンジェラン','グリスボック','アファームドS','アファームドB','アファームドC','ドルドレイ','サイファー','バルバドス','ブルーストーカー']
  };

  // 状態
  const state = { names: [], on:{}, weight:{} };

  const COOKIE_KEY = 'vrState';
  const COOKIE_MAX_AGE = 60 * 60 * 24 * 365; // 1年

  function normalizeWeightValue(v){
    let num = parseFloat(v);
    if (isNaN(num)) num = 1;
    if (num < 0.1) num = 0.1;
    if (num > 10) num = 10;
    return num;
  }

  function findMatchingPresetKey(names, on, weight){
    for (const [key, list] of Object.entries(PRESETS)){
      if (list.length !== names.length) continue;
      let matched = true;
      for (let i = 0; i < list.length; i++){
        if (list[i] !== names[i]){ matched = false; break; }
      }
      if (!matched) continue;
      for (const name of list){
        if (!on[name]){ matched = false; break; }
        const w = normalizeWeightValue(weight[name]);
        if (w !== 1){ matched = false; break; }
      }
      if (matched) return key;
    }
    return null;
  }

  function selectPresetRadio(value){
    const radios = document.querySelectorAll('#presets input[name="preset"]');
    for (const radio of radios){
      if (radio.value === value){
        radio.checked = true;
        break;
      }
    }
  }

  function saveStateToCookie(){
    try {
      const data = {
        names: state.names.slice(),
        on: Object.fromEntries(state.names.map(n => [n, !!state.on[n]])),
        weight: Object.fromEntries(state.names.map(n => [n, normalizeWeightValue(state.weight[n])]))
      };
      const json = JSON.stringify(data);
      document.cookie = `${COOKIE_KEY}=${encodeURIComponent(json)}; Max-Age=${COOKIE_MAX_AGE}; Path=/; SameSite=Lax`;
    } catch (err) {
      console.error('状態の保存に失敗しました', err);
    }
  }

  let cookieSaveTimer = null;
  function queueSaveStateToCookie(){
    clearTimeout(cookieSaveTimer);
    cookieSaveTimer = setTimeout(() => {
      cookieSaveTimer = null;
      saveStateToCookie();
    }, 0);
  }

  function loadStateFromCookie(){
    try {
      const cookies = document.cookie ? document.cookie.split(';') : [];
      const prefix = `${COOKIE_KEY}=`;
      const entry = cookies.map(c => c.trim()).find(c => c.startsWith(prefix));
      if (!entry) return false;
      const json = decodeURIComponent(entry.slice(prefix.length));
      if (!json) return false;
      const parsed = JSON.parse(json);
      if (!parsed || !Array.isArray(parsed.names)) return false;

      const names = [];
      for (const raw of parsed.names) {
        if (typeof raw !== 'string') continue;
        const name = raw.trim();
        if (!name) continue;
        names.push(name);
      }
      const on = {};
      const weight = {};
      const srcOn = parsed.on && typeof parsed.on === 'object' ? parsed.on : {};
      const srcWeight = parsed.weight && typeof parsed.weight === 'object' ? parsed.weight : {};
      for (const name of names) {
        on[name] = Object.prototype.hasOwnProperty.call(srcOn, name) ? !!srcOn[name] : true;
        weight[name] = normalizeWeightValue(srcWeight[name]);
      }
      state.names = names;
      state.on = on;
      state.weight = weight;
      const matchedPreset = findMatchingPresetKey(state.names, state.on, state.weight);
      if (matchedPreset){ selectPresetRadio(matchedPreset); }
      return true;
    } catch (err) {
      console.error('状態の読み込みに失敗しました', err);
      return false;
    }
  }

  // Wheel
  const TAU = Math.PI*2;
  const wheel = {
    ctx: null,
    dpr: Math.max(1, window.devicePixelRatio || 1),
    size: 520, radius: 220,
    rotation: 0, omega: 0,
    decelEndAt: 0, segs: [],
    initCtx(){
      if (!this.ctx) this.ctx = refs.wheel.getContext('2d');
    },
    hueColor(rad){
      const deg = (rad * 180 / Math.PI);
      const hue = ((deg + 150) % 360 + 360) % 360;
      return `hsl(${hue}, 70%, 75%)`; // パステル
    },
    rebuild(){
      this.initCtx();
      const items = [];
      for(const n of state.names){ if(state.on[n]) items.push({name:n, w: state.weight[n]||1}); }
      if(!items.length){ this.segs = []; this.draw(); return; }
      // シャッフルしない（順序＝state.namesのまま）
      const total = items.reduce((s,it)=>s+it.w,0);
      let a = 0; const segs=[];
      for(const it of items){
        const span = TAU * (it.w/total);
        const mid = a + span/2;
        segs.push({ name: it.name, start:a, end:a+span, color: this.hueColor(mid) });
        a += span;
      }
      this.segs = segs; this.draw();
    },
    pickCurrent(){
      if(!this.segs.length) return null;
      let ang = (-this.rotation - Math.PI/2) % TAU; if(ang<0) ang+=TAU;
      return this.segs.find(s => ang>=s.start && ang < s.end) || this.segs[this.segs.length-1];
    },
    draw(){
      this.initCtx();
      const ctx = this.ctx;
      const {size,dpr,radius} = this;
      if (ctx.reset) try{ ctx.reset(); }catch(_){}
      ctx.save();
      ctx.scale(dpr, dpr);
      ctx.clearRect(0,0,size,size);
      ctx.translate(size/2, size/2);
      ctx.rotate(this.rotation);

      for(const s of this.segs){
        ctx.beginPath(); ctx.moveTo(0,0); ctx.arc(0,0,radius, s.start, s.end, false); ctx.closePath();
        ctx.fillStyle = s.color; ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();

        const mid = (s.start+s.end)/2;
        ctx.save(); ctx.rotate(mid); ctx.translate(radius*0.7, 0); ctx.rotate(-mid);
        ctx.fillStyle = '#111'; ctx.font = 'bold 16px system-ui, Noto Sans JP, sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(s.name, 0, 0, radius*0.55);
        ctx.restore();
      }
      ctx.beginPath(); ctx.arc(0,0, radius*0.1, 0, TAU);
      ctx.fillStyle = '#fff'; ctx.fill(); ctx.strokeStyle='#222'; ctx.stroke();
      ctx.restore();

      const cur = this.pickCurrent();
      refs.current.textContent = cur ? cur.name : '';
    }
  };

  // 親幅が0のときはrAFで再試行してから実ピクセル確定（iPhone Safari対策）
  function resizeCanvas(retry=0){
    const canvas = refs.wheel;
    const parent = canvas.parentElement;
    const parentW = parent ? parent.clientWidth : 0;
    if (parentW === 0 && retry < 10){
      requestAnimationFrame(()=>resizeCanvas(retry+1));
      return;
    }
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssSize = Math.min(parentW || 320, 520);
    const px = Math.round(cssSize * dpr);
    if (canvas.width !== px || canvas.height !== px){
      canvas.width = px; canvas.height = px;
    }
    wheel.size = Math.round(cssSize);
    wheel.radius = Math.round(cssSize * 0.43);
    wheel.dpr = dpr;
    wheel.draw();
  }
  window.addEventListener('resize', ()=>resizeCanvas(), {passive:true});
  window.addEventListener('orientationchange', ()=>resizeCanvas(), {passive:true});

  // 名簿編集UI
    function renderChecks(){
      refs.checks.innerHTML = '';
      for(const name of state.names){
        const row = document.createElement('div'); row.className='row';
        const cb = document.createElement('input'); cb.type='checkbox'; cb.checked=!!state.on[name]; cb.dataset.name = name;
        cb.addEventListener('change',()=>{ state.on[name]=cb.checked; ui.toggleStart(); wheel.rebuild(); queueSaveStateToCookie(); });
        const nameInput = document.createElement('input'); nameInput.className='name'; nameInput.value=name;
        nameInput.addEventListener('change',()=>{ if(renameCharacter(name, nameInput.value)){ queueSaveStateToCookie(); } });
        const w = document.createElement('input'); w.className='weight'; w.type='number'; w.min=0.1; w.max=10; w.step='any'; w.value=state.weight[name]; w.inputMode='decimal'; w.setAttribute('aria-label','重み'); w.title='重み';
        w.addEventListener('input',()=>{ let v=parseFloat(w.value); if(isNaN(v)) v=1; if(v<0.1) v=0.1; if(v>10) v=10; state.weight[name]=v; w.value=v; wheel.rebuild(); });
        w.addEventListener('change',()=>{ queueSaveStateToCookie(); });
        const del = document.createElement('button'); del.className='remove'; del.textContent='削除';
        del.addEventListener('click',()=>{ if(removeCharacter(name)){ queueSaveStateToCookie(); } });
        row.append(cb, nameInput, w, del);
        refs.checks.appendChild(row);
      }
      ui.toggleStart();
    }
  function renameCharacter(oldName, newName){
    newName = (newName||'').trim(); if(!newName || newName===oldName) { renderChecks(); return false; }
    const on = !!state.on[oldName]; const w = state.weight[oldName] ?? 1;
    const idx = state.names.indexOf(oldName); if(idx>=0) state.names[idx]=newName;
    delete state.on[oldName]; delete state.weight[oldName];
    state.on[newName] = on; state.weight[newName] = w;
    wheel.rebuild(); renderChecks();
    return true;
  }
  function removeCharacter(name){
    const before = state.names.length;
    state.names = state.names.filter(n => n!==name);
    const changed = state.names.length !== before;
    if(changed){
      delete state.on[name]; delete state.weight[name];
      wheel.rebuild();
    }
    renderChecks();
    return changed;
  }
  refs.add.addEventListener('click',()=>{
    const name = (refs.newName.value||'').trim(); if(!name) return;
    let v = parseFloat(refs.newWeight.value); if(isNaN(v)) v=1; if(v<0.1) v=0.1; if(v>10) v=10;
    state.names.push(name); state.on[name]=true; state.weight[name]=v;
    refs.newName.value=''; refs.newWeight.value='1';
    wheel.rebuild(); renderChecks();
    queueSaveStateToCookie();
  });

    function updateSelections(mapper){
      const cbs = refs.checks.querySelectorAll('input[type="checkbox"]');
      let changed = false;
      cbs.forEach(cb => {
        const name = cb.dataset.name;
        const prev = cb.checked;
        const next = !!mapper(prev, name);
        if(prev !== next){
          cb.checked = next;
          state.on[name] = next;
          changed = true;
        }
      });
      if(changed){
        wheel.rebuild();
        queueSaveStateToCookie();
        ui.toggleStart();
      }
    }

  refs.allOn.addEventListener('click',()=>{ updateSelections(()=>true); });
  refs.allOff.addEventListener('click',()=>{ updateSelections(()=>false); });
  refs.invert.addEventListener('click',()=>{ updateSelections(prev=>!prev); });

  // ===== UI制御 =====
  const ui = { toggleStart(){ refs.start.disabled = (wheel.segs.length<1) || anim.running; } };

  // ===== アニメーション（requestAnimationFrameで駆動） =====
  const anim = {
    running:false, frameId:0, last:0, autoDecelId:0, autoStopId:0, loopCb:null,
    start(){
      if(this.running || !wheel.segs.length) return;
      let total = clamp(parseFloat(refs.maxTime.value), 1, 20);
      let decel = clamp(parseFloat(refs.decelTime.value), 0.2, 3);
      if (decel >= total) decel = Math.max(0.2, total * 0.4);
      refs.maxTime.value = total.toFixed(1); refs.decelTime.value = decel.toFixed(1);

      this.running = true;
      wheel.rotation = Math.random() * Math.PI * 2;
      wheel.omega = 10 + Math.random()*4; // 10〜14 rad/s
      ui.toggleStart(); refs.stop.disabled=false;

      wheel.decelEndAt = 0; this.last = performance.now();
      if(!this.loopCb){ this.loopCb = (now) => this.loop(now); }
      this.frameId = requestAnimationFrame(this.loopCb);

      clearTimeout(this.autoDecelId); clearTimeout(this.autoStopId);
      this.autoDecelId = setTimeout(()=>control.requestDecel(decel), Math.max(0, (total - decel))*1000);
      this.autoStopId  = setTimeout(()=>control.stop(),                total*1000);
    },
    loop(now){
      if(!this.running){ this.frameId = 0; return; }
      const dt = Math.max(0, Math.min(0.05, (now - this.last)/1000)); this.last = now;

      if(wheel.decelEndAt){
        const tLeft = (wheel.decelEndAt - now)/1000; const dur = wheel.decelDur;
        wheel.omega = tLeft>0 ? wheel.omega0 * (tLeft/dur) : 0;
        if(tLeft<=0){ wheel.omega = 0; this.running=false; control.finalize(); return; }
      }
      wheel.rotation = (wheel.rotation + wheel.omega * dt) % (Math.PI*2);
      wheel.draw();
      if(this.running){
        this.frameId = requestAnimationFrame(this.loopCb || (this.loopCb = (time)=>this.loop(time)));
      } else {
        this.frameId = 0;
      }
    },
    stop(){
      if(this.frameId){ cancelAnimationFrame(this.frameId); this.frameId = 0; }
      this.running=false;
      clearTimeout(this.autoDecelId); this.autoDecelId = 0;
      clearTimeout(this.autoStopId);  this.autoStopId = 0;
    }
  };

  function clamp(v, lo, hi){ v = isNaN(v)?lo:v; return Math.min(hi, Math.max(lo, v)); }

  // ===== 操作群 =====
  const control = {
    start(){
      if(!wheel.segs.length){ wheel.rebuild(); }
      if(!wheel.segs.length){ ui.toggleStart(); return; }
      anim.start();
    },
    requestDecel(decel){
      if(anim.running && !wheel.decelEndAt){
        wheel.decelDur = clamp(decel ?? parseFloat(refs.decelTime.value), 0.2, 3);
        wheel.omega0   = Math.max(2, wheel.omega);
        wheel.decelEndAt = performance.now() + wheel.decelDur*1000;
        refs.stop.disabled = true;
      }
    },
    stop(){ if(anim.running) this.requestDecel(); },
    finalize(){
      let rot = wheel.rotation + (Math.random() - 0.5) * (Math.PI / 90);
      wheel.rotation = (rot % (Math.PI*2) + Math.PI*2) % (Math.PI*2);
      const win = wheel.pickCurrent();
      wheel.draw();
      refs.current.textContent = win ? win.name : '';
      refs.current.classList.remove('pop'); void refs.current.offsetWidth; refs.current.classList.add('pop');
      refs.start.disabled=false;
      refs.stop.disabled=true;
      anim.stop();
    }
  };

  // ★ タップ系イベントでも起動（クリックに加えて）
  const startHandler = (e)=>{ e.preventDefault(); control.start(); };
  refs.start.addEventListener('click', startHandler);
  refs.start.addEventListener('pointerdown', startHandler, {passive:false});
  refs.start.addEventListener('touchstart', startHandler, {passive:false});
 
  function applyPreset(key){
    const list = PRESETS[key]; if(!Array.isArray(list)) return false;
    state.names  = list.slice();
    state.on     = Object.fromEntries(state.names.map(n => [n,true]));
    state.weight = Object.fromEntries(state.names.map(n => [n,1]));
    renderChecks(); wheel.rebuild(); ui.toggleStart();
    return true;
  }

  document.querySelectorAll('#presets input[name="preset"]').forEach(r => {
    r.addEventListener('change', () => { if(applyPreset(r.value)){ queueSaveStateToCookie(); } });
  });

  function init(){
    const loaded = loadStateFromCookie();
    if (loaded){
      renderChecks();
      wheel.rebuild();
      ui.toggleStart();
    } else {
      selectPresetRadio('オラタン');
      applyPreset('オラタン');
    }
    queueSaveStateToCookie();
    requestAnimationFrame(()=>{ resizeCanvas(); });
  }
  document.addEventListener('DOMContentLoaded', init, {once:true});

  // --- PWA: Service Worker 登録 ---
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js');
    });
  }
})();
</script>
</body>
</html>
